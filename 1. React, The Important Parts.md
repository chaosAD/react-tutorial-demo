#React, The Important Parts üßê

- [React Components](#react-components)
- [State](#state)
- [User Interaction](#ui)

<h2 id="react-components">React Components</h2>

React uses **components** to organize complex websites into **small bits of code**. The <u>src/App.js</u> file that we previously edited was a React component.

```react
/* HelloWorld.js */

// 1.
import React from "react";

// 2.
class HelloWorld extends React.Component {
  // 3.
  render() {
    return <p>Hello World</p>
  }
}

// 4.
export default HelloWorld;
```

`HelloWorld` is also a React component. React components are JavaScript classes. JavaScript classes are no different from Java classes except that you don't need special modifiers such as `public` and types such as `int` before declaring things. There are some general rules that you must follow for React components.

- Firstly,  **every React should must extend the `React.Component` class**. If you don't, you'll get some nasty errors in your code. Extending  `React.Component` tells React that your class is not any ordinary JavaScript class‚Äîit's a React component.
- Secondly, **every React should must`import "react"`**. This follows the first rule‚Äîyou need to import React to extend it's component class.
- Thirdly, **every React component should have a `render()` method**. This tells React what to show the user when the component is used.
- Lastly, **every file have the same name as it's React class**, just like a Java class. Additionally, Every file should also `export default` their class. Should you want to import the component from another class, you need to make it easily accessible.

###Components for Dummies ü§™

Every React component is a JavaScript class contained in a single file. Let's take a look at an example.

```react
class Date extends React.Component {
  render() {
    let year = new Date().getFullYear();
    return <p>It's {year}!</p>
  }
}
```

Notice how our `Date` component extends the `React.Component` class. React components, as we went over, we **must** do this. Also notice how our class again has a  `render()` that returns some HTML-like syntax. In React, the `render()` method is expected to return the *view* of a component class. 

The *view* of a component is the code for what the user is able to see. It's basically the HTML that's attached to the component in question. In this instance, our view is "It's 2019!" because that's what the user would see if we used this component.

Ok, things are starting to make sense, but something's still odd here. Why is there HTML-like text inside of our JavaScript anyway? Aren't HTML and JavaScript two seperate langauges. To answer how this works, you must a understand special syntax called **JSX**.

####JSX in Plain English

JSX is a HTML-like language that React uses to create React components and HTML elements. It's basically a fancy way of creating HTML elements and new React components in JavaScript, nothing more. React developers use JSX because it's more readable than writing JavaScript.

```react
// This JSX represents a paragraph element with "It's 2019" inside.
<p>It's {new Date().getFullYear()}!</p>
```

The above JSX is actually the exact same thing as...

```react
// Returns a paragraph element with "It's 2019" inside.
React.createElement("p", null, "It's "+ new Date().getFullYear() + "!");
```

**Both are objects,** meaning that you can assign them to variables for later use.

```react
const pElement = <p>It's {new Date().getFullYear()}!</p>
```

One handy feature that JSX has is that it lets you insert or "interpolate" JavaScript expressions into elements with curly braces.

```react
// We use curly braces to insert or "interpolate" expressions.
<p>It's {new Date().getFullYear()}!</p>
```

In this example,  the `new Date().getFullYear()` expression returns the current year as a number, which is then casted into a string by React and displayed.

*P.S. Don't accidentally interpolate statements. Only valid [expressions](https://stackoverflow.com/questions/18443801/in-programming-what-is-an-expression) are permitted!.*

```react
// ‚õîÔ∏è You can't do this! "if" statements are not expressions.
<p>You { if (age < 21) { return "can't"; } return "can"; } legally drink!</p>
```

To make this code work as intended, you can replace the "if" statements with a ternary operator.

```react
// ‚úÖ Ternary operators are expressions.
<p>You { age < 21 ? "can't" : "can" } legally drink!</p>
```

###The Component Tree üå¥

Components are cool, but what if components could contain other components? React allows us to **nest** components, just like HTML. This creates a "tree" like data structure‚Äîcomponents with other components as children.

```react
// Import components and "React" as needed.
import React from "react";
import NavigationBar from "./NavigationBar.js";
import MainContainer from "./MainContainer.js";

class App extends React.Component {
  render() {
    return (
      <div>
        <NavigationBar />
        <MainContainer />
      </div>
    );
  }
}

// Export every component so that other components can import them.
export default App;
```

Notice how our JSX contains a mixture of HTML and React components. `div` is and HTML element while `NavigationBar` and `MainContainer` are both React components. This is intentional‚Äîget used to thinking of the React components that you create as ordinary HTML elements that you can import.

Don't get too clever with nesting components. Each component or element can nested multiple component or elements, but each component definition can only contain one element.

```jsx
// ‚õîÔ∏è This will give us some nasty errors. This components definition has multiple components.
class App extends React.Component {
  render() {
    return (
        <NavigationBar />
        <MainContainer />
      	<div>Test</div>
    );
  }
}
```

```jsx
class App extends React.Component {
  render() {
    return (
      <div> {/* ‚úÖ We absolutely need this div! Now our component definition only has one element. */}
        <NavigationBar />
        <MainContainer />
        <div>Test</div>
      </div>
    );
  }
}
```

<h2 id="state">State </h2>

In React, **state** is the smallest amount of information that a component needs to `render()` a view correctly. Notice how I italicized *minimum*. It's important that we keep our state as small as possible. Let's work through some examples!

Consider a todo application. More specifically, consider the minimum amound of information that your might need to make one. You'll likely need:

- A list of items `[]`
- Some indication of each item's completion `{ completed: true, name: "Sell concert tickets." }`

A **state object** for a todo application might look like...

```javascript
state = {
  items: [
    { completed: false, name: "Actually do my homework." },
    { completed: true, name: "Sell concert tickets." }
  ]
};
```

Notice how small this state object is. It's very clear what information the state object conveys here‚Äîa list of items, each with two properties, `completed` and `name`. This state object works well because it communicates the smallest amount of information that a component might need to know to render a view.

####What is this syntax?

In JavaScript, curly brackets  `{}`  and colons  `:`  are part of the [syntax](https://www.w3schools.com/js/js_objects.asp) for defining properties and values for objects. In the example above, our `state` object has an `items` property which contains an array of objects each containing `completed` and `name` properties.

###Adding "State" to our View

In React, each component has it's own **state object**.

```jsx
/* TodoApp.js */
import React from "react";

class TodoApp extends React.Component {
 	// State object
  state = {
    items: [
      { completed: false, name: "Actually do my homework." },
      { completed: true, name: "Sell concert tickets." }
    ]
  };
	
  render() {
    // Access the state object using "this." syntax, just like Java.
    return <div>You have {this.state.items.length} todo items.</div>;
  }
}

export default TodoApp;
```

In React, each component also has a `render()` method. This is the most React's most critical symbiosis. This pattern is great because as we *modify* our `state` object  it's very plain to see what the `render()`  method will display. React does the importnat work of figuring our how to call the `render()` method with fresh values as efficiently as possible.

In the next section about User Interaction, I'll discuss the exact mechanism and process for *modifying* our `state ` object in response to events and other things.

###Complex Views

Let's modify our `render()` method to render the todo items instead of the length of our list. However, before doing so, let me introduce you to a special JavaScript method‚Äîthe "map" method.

#### `map` all of the things

Every JavaScript array has a `map` method on it. The `map` method goes through every array item in order, calls a function on each one, and returns all of results in a new array of the same length.

```javascript
let numbers = [1, 5, 6, 2];

let squaredNumbers = numbers.map(function(number) {
  return number * number;
});
```

The result of the above function would be `[1, 25, 36, 4]`. Why? If we apply the function passed to the `map` method on the `numbers` array on every `number`, we get  `[1, 25, 36, 4]`.

Let's try another example.

```react
let foods = ["pho", "corn", "broccoli"];

let foodElements = foods.map((food) => {
  return <li>{food}</li>;
});
```

The result of the above call would be `[<li>pho<li>, <li>corn</li>, <li>broccoli</li>]`. This works becaus, aforementioned, JSX element are objects, so they can be stored in arrays.

Notice how I used `(food) =>` instead of `function(food)`. The `=>` is called an JS arrow. `(food) =>` is an arrow function. Use arrow functions over regular functions.

Let's apply these lessons to our todo application.

```react
import React from "react";

class TodoApp extends React.Component {
  state = {
    items: [
      { completed: false, name: "Actually do my homework." },
      { completed: true, name: "Sell concert tickets." }
    ]
  };
	
  render() {
    return (
      <div>
        {
          this.state.items.map((item) => {
            return <p>{item.name} - {item.completed ? "Completed" : "Not Completed"}</p>;
          })
        }
      </div>
  	);
  }
}

export default TodoApp;
```

Now we know how to format our `state` into a nicely formatted view!

<h2 id="ui">User Interaction and Events ‚òùüèΩ</h2>

So how *do* we modify the state of React components? When a user clicks a part of the page, drags their mouse, or taps their keyboard, how do we respond? To modify the `state` of a React component, we use the `setState` method. This method comes for free when we extend the `React.Component` class.

```react
/* Counter.js */
import React from "react";

class Counter extends React.Component {
  state = {
    count: 0
  };

  render() {
    return (
      <div>
        <button onClick={() => {
        	this.setState({ count: this.state.count + 1 });
        }}>
          +
        </button>
        <button onClick={() => {
        	this.setState({ count: this.state.count - 1 });
        }}>
          -
        </button>
        <p>Counter: {this.state.count}</p>
      </div>
    );
  }
}

export default Counter;
```

Every time that a user clicks on the "Increment" `button`, JavaScript triggers the function contained within the expression at the `onClick` attribute on the `button` element.

This function calls the `setState` method, which updates the `count` property on the state object by one. ( `this.setState({ count: this.state.count + 1 })`). Notice how we don't modify the state object directly.

```javascript
// ‚õîÔ∏è This does nothing.
this.state.count = this.state.count + 1;
```
Using `setState` is the only way to properly modify state in React. Don't do the above.

```javascript
// ‚úÖ This is valid. 
this.setState({
  count: this.state.count + 1
});
```

Whats most important about the  `setState` method is that it updates the `state` object everywhere inside of the`render()` method with a fresh value when it is called. In this instance, after we click on the "+" `button`, the JavaScript expression within our paragraph element returns a new, incremented value ([Check it out](https://codesandbox.io/s/react-counter-vvb10?fontsize=14)).

Behind the scenes...

1. When the button is clicked, React calls the `onClick` function that we passed to it.
2. The  `onClick` calls the `setState` method which is used to update the `state` of our React component.
3. The  `setState` method updates the `state` with properties changed. `setState` sets the `count` property from value `this.state.count` to `this.state.count + 1`.
4. React calls the `render()` method with a fresh `count` value, so we see an updated value next to "Counter: ". Every time that we update a property value in our `state` object using the `setState` method, every place that we use the  `state` is automatically updated.

##Next steps üë£

- Play around with and extend this code in your editor!
- Edit the `state` object to make it your own and try rendering it with all different [HTML elements](https://www.w3schools.com/html/html_elements.asp) that you've learned about!
- Create cool effects with different events. Try adding style and changing text in response to mouse events, scroll events, and other events.
- Follow these links and skim over content.
  - [Inline Styles](https://reactjs.org/docs/dom-elements.html#style)
  - [Styling with CSS](https://reactjs.org/docs/faq-styling.html)
  - [React Events](https://reactjs.org/docs/handling-events.html)